/** Sabre, an anonymous bulletin board with speedier ripostes
 *  Copyright (C) 2020  Sabre authors
 *
 *  @file    gen_constants.cpp
 *  @brief   
 *
 *  @author  Ryan Henry        <ryan.henry@ucalgary.ca>
 *  @author  Adithya Vadapalli <avadapal@iu.edu>
 *  @author  Kyle Storrier     <kyle.storrier@ucalgary.ca>
 *
 *  @license GNU Public License (version 2); see LICENSE for full license text
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License along
 *    with this program; if not, write to the Free Software Foundation, Inc.,
 *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 **/
 

#include <iostream>
#include <iomanip>
#include <vector>
#include <bitset> 

#include <cassert>
#include<tuple>
#include <set>
#include "lowmc.h"

namespace lowmc
{  

constexpr size_t block_len = BLOCK_LEN;
constexpr size_t rounds = ROUNDS; 
constexpr size_t sboxes = SBOXES;
constexpr size_t ndpfs = NDPFS;

using block_t = lowmc<block_len,rounds,sboxes>::block_t;

unsigned int compute_rank(const std::vector<block_t> & matrix) 
{
	auto matrix_copy = matrix;
	unsigned size = matrix_copy[0].size();

	//Transform to upper triangular matrix
	unsigned row = 0;
	for (unsigned col = 1; col <= size; ++col)
	{
		if (!matrix_copy[row][size-col])
		{
			unsigned r = row;
			while (r < matrix_copy.size() && !matrix_copy[r][size-col]) ++r; 

			if (r >= matrix_copy.size())
			{
				continue;
			}
			else
			{
				auto temp = matrix_copy[row];
				matrix_copy[row] = matrix_copy[r];
				matrix_copy[r] = temp;
			}
		}
		for (unsigned i = row+1; i < matrix_copy.size(); ++i)
		{
			if (matrix_copy[i][size-col]) matrix_copy[i] ^= matrix_copy[row];
		}
		++row;
		if (row == size) break;
	}
	return row;
}

bool getrandbit()
{
	static std::bitset<80> state; //Keeps the 80 bit LSFR state
	bool tmp = 0;
	//If state has not been initialized yet
	if (state.none())
	{
		state.set(); //Initialize with all bits set
		//Throw the first 160 bits away
		for (unsigned i = 0; i < 160; ++i)
		{
			//Update the state
			tmp =  state[0] ^ state[13] ^ state[23] ^ state[38] ^ state[51] ^ state[62];
			state >>= 1;
			state[79] = tmp;
		}
	}
	//choice records whether the first bit is 1 or 0.
	//The second bit is produced if the first bit is 1.
	bool choice = false;
	do
	{
		//Update the state
		tmp =  state[0] ^ state[13] ^ state[23] ^ state[38] ^ state[51] ^ state[62];
		state >>= 1;
		state[79] = tmp;
		choice = tmp;
		tmp = state[0] ^ state[13] ^ state[23] ^ state[38] ^ state[51] ^ state[62];
		state >>= 1;
		state[79] = tmp;
	} while (!choice);

	return tmp;
}

block_t getrandblock()
{
	block_t tmp = 0;
	for (unsigned i = 0; i < block_len; ++i) tmp[i] = getrandbit();
	return tmp;
}

auto transpose(const std::vector<block_t> & matrix)
{
	size_t blocklen = 8 * sizeof(block_t); 
	std::vector<block_t> transposed(blocklen);
	for (size_t i = 0; i < blocklen; ++i)
	{
		for (size_t j = 0; j < blocklen; ++j)
		{
			transposed[j][i] = matrix[i][j];
		}
	}
	return transposed;
}

} // namespace lowmc

using namespace lowmc;

int main(int argc, char * argv[])
{
	std::vector<std::vector<block_t>> matrices;
	std::vector<std::vector<block_t>> transposed;
	for (size_t i = 0; i < rounds; ++i)
	{
        std::vector<block_t> mat;
        do
        {
            mat.clear();
            for (unsigned i = 0; i < block_len; ++i)
            {
                mat.push_back(getrandblock());
            }
        } while (compute_rank(mat) != block_len);
        matrices.push_back(mat);
        transposed.push_back(transpose(mat));
    }
	std::vector<block_t> round_constants;
    //round_constants.push_back(0);
	for (unsigned r = 0; r < rounds; ++r)
	{
		round_constants.push_back(getrandblock());
	}
	auto constants = reinterpret_cast<uint64_t *>(round_constants.data());

 


	size_t i, j, ii, jj;
	std::cout << std::setfill('0');
	std::cout << "#ifndef LOWMC_CONSTANTS_B" << block_len << "_R" << rounds
	          <<     "_S" << sboxes << "_H__\n"
	          << "#define LOWMC_CONSTANTS_B" << block_len << "_R" << rounds
	          <<     "_S" << sboxes << "_H__\n\n"
	          << "#include <x86intrin.h>\n\n"
	          << "/* THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. */\n\n"
	          << "// constexpr size_t block_len = " << block_len << ";\n"
	          << "// constexpr size_t rounds    = " << rounds << ";\n"
	          << "// constexpr size_t sboxes    = " << sboxes << ";\n\n"
	          << "namespace lowmc\n"
	          << "{\n\n"
	          << "alignas(alignof(__m" << block_len << "i))\n"
	          << "static constexpr uint64_t consts_b" << block_len << "_r"
	          <<     rounds << "_s" << sboxes << "[" << block_len/64 << "*"
	          <<     rounds << "] = {\n";

	std::cout << std::hex;
	auto len = (block_len/64) * rounds;
	for (i = 0, ii = 0; i < len/4-1; ++i, ii+=4)
	{
		std::cout << "\t0x" << std::setw(16) << constants[ii+0]
		          << ", 0x" << std::setw(16) << constants[ii+1]
		          << ", 0x" << std::setw(16) << constants[ii+2]
		          << ", 0x" << std::setw(16) << constants[ii+3] << ",\n";
	}
	std::cout << "\t0x" << std::setw(16) << constants[ii++];
	while (ii < len) std::cout << ", 0x" << std::setw(16) << constants[ii++];
	std::cout << "\n";

	std::cout << std::dec;

	std::cout << "}; // consts_b" << block_len << "_r" << rounds << "_s" 
	          <<     sboxes << "\n\n"
	          << "template<>\n"
	          << "const lowmc<" << block_len << "," << rounds << "," << sboxes
	          <<     ">::block_t * lowmc<" << block_len << ","
	          <<     rounds <<     "," << sboxes << ">::round_constants\n"
	          << "\t= reinterpret_cast<const lowmc<" << block_len << ","
	          <<     rounds << "," << sboxes << ">::block_t*>(consts_b"
	          <<     block_len << "_r" << rounds << "_s" << sboxes << ");\n\n"
	          << "template<>\n"
	          << "const bitsliced_lowmc<" << block_len << "," << rounds << ","
	          <<     sboxes << ", " << ndpfs << ">::block_t * bitsliced_lowmc<" << block_len
	          <<     "," << rounds << "," << sboxes << "," << ndpfs << ">::round_constants\n"
	          << "\t= reinterpret_cast<const lowmc<" << block_len << ","
	          <<     rounds << "," << sboxes << ">::block_t*>(consts_b"
	          <<     block_len << "_r" << rounds << "_s" << sboxes << ");\n\n"
	          << "template<> alignas(alignof(__m" << block_len << "i))\n"
	          << "const uint64_t lowmc<" << block_len << "," << rounds << ","
	          <<     sboxes << ">::matrices[" << rounds << "][" << block_len/64
	          <<     "*" << block_len << "] = {\n";

	len = (block_len/64)*block_len;
	for (i = 0; i < rounds; ++i)
	{
		auto mat = reinterpret_cast<uint64_t *>(matrices[i].data());
		std::cout << "  {  // begin lowmc::matrices[" << i << "]  (out of "
		          <<     (rounds-1) << ")\n";
		std::cout << std::hex;
		for (j = 0, jj = 0; j < len/4-1; ++j, jj+=4)
		{
			std::cout << "\t0x" << std::setw(16) << mat[jj+0]
			          << ", 0x" << std::setw(16) << mat[jj+1]
			          << ", 0x" << std::setw(16) << mat[jj+2]
			          << ", 0x" << std::setw(16) << mat[jj+3]
			          << ",\n";
		}
		std::cout << "\t0x" << std::setw(16) << mat[jj++];
		while (jj < len) std::cout << ", 0x" << std::setw(16) << mat[jj++];
		std::cout << "\n";
		std::cout << std::dec;
		std::cout << "  }" << (i < rounds-1 ? "," : "")
		          <<     " // end  lowmc::matrices[" << i << "]   (out of "
		          <<     (rounds-1) << ")\n";
	}

	std::cout << "}; // lowmc<" << block_len << "," << rounds << "," << sboxes
	          <<     ">::matrices\n\n";
	std::cout << "template <>\n"
	          << "const uint64_t lowmc<" << block_len << "," << rounds << ","
	          <<     sboxes << ">::matrices2[" << rounds << "][" << block_len/64
	          <<     "*" << block_len << "/4][16*" << (block_len/64)
	          <<     "] = {\n";
/*
	len = (block_len/64)*block_len;
	for (i = 0; i < rounds; ++i)
	{
		auto mat = reinterpret_cast<uint64_t *>(matrices[i].data());
		std::cout << "  {  // begin matrices2[" << i << "]  (out of "
		          <<     (rounds-1) << ")\n";
		std::cout << std::hex;
		for (j = 0, jj = 0; j < len/4-1; ++j, jj+=4)
		{
			std::cout << "   {";
		std::cout << "0x" << std::setw(16) << 0
		          << ", 0x" << std::setw(16) << mat[jj+0]
		          << ", 0x" << std::setw(16) << mat[jj+1]
		          << ", 0x" << std::setw(16) << (mat[jj+0]^mat[jj+1]) << ",\n"
		          << "\t0x" << std::setw(16) << mat[jj+2]
		          << ", 0x" << std::setw(16) << (mat[jj+2] ^ mat[jj+0])
		          << ", 0x" << std::setw(16) << (mat[jj+2] ^ mat[jj+1])
		          << ", 0x" << std::setw(16) << (mat[jj+2] ^ mat[jj+1] ^ mat[jj+0])	<< ",\n"
		          << "\t0x" << std::setw(16) << mat[jj+3]
		          << ", 0x" << std::setw(16) << (mat[jj+3] ^ mat[jj+0])
		          << ", 0x" << std::setw(16) << (mat[jj+3] ^ mat[jj+1])
		          << ", 0x" << std::setw(16) << (mat[jj+3] ^ mat[jj+1] ^ mat[jj+0]) << ",\n"
		          << "\t0x" << std::setw(16) << (mat[jj+3] ^ mat[jj+2])
		          << ", 0x" << std::setw(16) << (mat[jj+3] ^ mat[jj+2] ^ mat[jj+0])
		          << ", 0x" << std::setw(16) << (mat[jj+3] ^ mat[jj+2] ^ mat[jj+1])
		          << ", 0x" << std::setw(16) << (mat[jj+3] ^ mat[jj+2] ^ mat[jj+1] ^ mat[jj+0]) << "},\n";
		}
		std::cout << "\t0x" << std::setw(16) << mat[jj++];
		while (jj < len) std::cout << ", 0x" << std::setw(16) << mat[jj++];
		std::cout << "\n";
		std::cout << std::dec;
		std::cout << "  }" << (i < rounds-1 ? "," : "")
		          <<     " // end  matrices2[" << i << "]   (out of "
		          <<     (rounds-1) << ")\n";
	}
*/
	std::cout << "}; // lowmc<" << block_len << "," << rounds << "," << sboxes
	          <<     ">::matrices2\n\n";


	std::cout << "template <>\n"
	          << "const uint64_t bitsliced_lowmc<" << block_len << "," << rounds
	          <<     "," << sboxes << "," << ndpfs << ">::matrices[" << rounds << "]["
	          <<     block_len/64 << "*" << block_len << "] = {\n";

	for (i = 0; i < rounds; ++i)
	{
		auto mat = reinterpret_cast<uint64_t *>(transposed[i].data());
		std::cout << "  {  // begin bitsliced_lowmc::matrices[" << i
		          <<     "]  (out of " << (rounds-1) << ")\n";
		std::cout << std::hex;
		for (j = 0, jj = 0; j < len/4-1; ++j, jj+=4)
		{
			std::cout << "\t0x" << std::setw(16) << mat[jj+0]
			          << ", 0x" << std::setw(16) << mat[jj+1]
			          << ", 0x" << std::setw(16) << mat[jj+2]
			          << ", 0x" << std::setw(16) << mat[jj+3]
			          << ",\n";
		}
		std::cout << "\t0x" << std::setw(16) << mat[jj++];
		while (jj < len) std::cout << ", 0x" << std::setw(16) << mat[jj++];
		std::cout << "\n";
		std::cout << std::dec;
		std::cout << "  }" << (i < rounds-1 ? "," : "")
		          <<     " // end  bitsliced_lowmc::matrices2[" << i
		          <<     "]   (out of " << (rounds-1) << ")\n";
	}

	std::cout << "}; // bitsliced_lowmc<" << block_len << "," << rounds << ","
	          <<     sboxes << "," << ndpfs << ">::matrices2\n\n";

 


#define NROWS 128
#define NCOLS 32
	std::vector< std::tuple<int, int, int> > lut_recipe[NCOLS];
	//uint8_t matrix8[NROWS*NCOLS] = reinterpret_cast<uint8_t * >(matrices[i].data());; // the matrix, cast to an array of uint8_t
	auto matrix8 = reinterpret_cast<uint8_t *>(transposed.data());

	for (int j = 0; j < NCOLS; ++j)
	{
		// lexicographic (popcount, ordinal value) comparator
		auto cmp = [](uint8_t a, uint8_t b) { return std::make_pair(__builtin_popcount(a), a) < std::make_pair(__builtin_popcount(b), b); };
		std::set<uint8_t, decltype(cmp)> to_compute(cmp);
		for (int r = 0; r < NROWS; ++r)
		{
			auto i = matrix8[j*NCOLS+r];
			std::cerr << "i  = " << (int) i << std::endl;
			if (__builtin_popcount(i) > 1) to_compute.insert(i);
		}
		std::set<uint8_t, decltype(cmp)> did_compute({ 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 }, cmp);

		while (!to_compute.empty())
		{
			bool progress;
			do
			{
				progress = false;
				for (auto it = to_compute.begin(); it != to_compute.end(); )
				{
					auto i = *it++;
					for (auto jj : did_compute)
					{
						if (did_compute.count(i^jj))
						{
							lut_recipe[j].push_back(std::make_tuple(i, jj, i^jj));
							to_compute.erase(i);
							did_compute.insert(i);
							progress = true;
							break;
						}
					}
				}
			} while (progress);

			if (!to_compute.empty())
			{
				auto i = *to_compute.begin();
				for (uint8_t subset=(i-1)&i; subset != 0; subset=(subset-1)&i)
				{
						//auto complement = i-subset;
						if (did_compute.count(subset))
						{
							uint8_t curr = 1U << __builtin_ctz(subset);
							// compute complement the naive way
							while (subset-curr)
							{
								uint8_t next = 1U << __builtin_ctz(subset-curr);
								lut_recipe[j].push_back(std::make_tuple(curr+next, curr, next));
								curr+=next;
								did_compute.insert(curr);
							}
							to_compute.erase(i);
							did_compute.insert(i);
							continue;
						} 
				}
			}
		}

	}


	 size_t total_len = 0; 
	// size_t lut_recipe_len[NCOLS];
	

	std::cout << "const size_t NCOLS = " << NCOLS << ";\n"; 	
	std::cout << "template<>\n";
	std::cout << "const size_t bitsliced_lowmc<" << block_len << "," << rounds
	          <<     "," << sboxes << "," << ndpfs << ">::recipe_len[NCOLS] = {"; 
	
	for(size_t j = 0; j < NCOLS; ++j)
	{	 
		 total_len += lut_recipe[j].size();

		 std::cout << lut_recipe[j].size();

		 if(j < NCOLS - 1) std::cout << ", ";
 
	}

 

   std::cout << "};\n";
 	
   size_t count = 0; 	
 
   std::cout << "template<>\n";
   std::cout << "const std::tuple<int, int, int> bitsliced_lowmc<" << block_len << "," << rounds
	          <<     "," << sboxes << "," << ndpfs << ">::lut_recipe_[] = {";
   for(size_t cols = 0; cols < NCOLS; ++cols) 
   {
     for(size_t i = 0; i < lut_recipe[cols].size(); ++i)
	  {
	  	std::cout << "std::make_tuple(" << std::get<0>(lut_recipe[cols][i]) << " , " << 
	  							std::get<1>(lut_recipe[cols][i]) << ", " << std::get<2>(lut_recipe[cols][i])  <<    ")";
	  	if(count < total_len - 1) std::cout << ", ";
	  	++count; 
	   }
    }

    std::cout << "};\n";


	std::cout << "} // namespace lowmc\n\n"
	          << "#endif // LOWMC_CONSTANTS_B" << block_len << "_R" << rounds
	          <<     "_S" << sboxes << "_H__" << std::endl;
	return 0;
} // main